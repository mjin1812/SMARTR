---
title: "Denny Lab Wholebrain Pipeline Demo"
author: ' by Michelle Jin'
date: "June 15, 2021"
output:
  html_document: default
  word_document: default
---

<div style="line-height: 2em;">
<font size="4"> 
<style type="text/css">

h1.title {
  font-size: 38px;
  color: Black;
  text-align: center;
}
h4.author { /* Header 4 - and the author and data headers use this too  */
  font-size: 18px;
  color: Black;
  text-align: center;
}
h4.date { /* Header 4 - and the author and data headers use this too  */
  font-size: 18px;
  color: Black;
  text-align: center;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```



# Introduction

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook that allows for an interactive walkthrough of the wholebrain pipeline for the lab.. When you execute code within the notebook, the results will appear beneath the code. To execute a code chunk in this notebook click the *Run* button within a chunk or place your cursor inside it and pressing *Ctrl+Shift+Enter*. 

The base of this pipeline is an R package in development with the working title, `SMARTR`, a self-referential play on the previous package I developed as an extension to `wholebrain` called `SMART`. 

In this notebook, a prototypical example of of the following steps of the pipeline will be demonstrated:

1. Setting up the pipeline by specifying experiment parameters, and save directories.
2. The interactive registration process.
3. Importing raw segmentation data from .txt files generated from ImageJ for multiple channels.
4. TODO: Optionally creating a filter for the 'cfos' and 'eyfp' channels to clean segmented counts. #Currently needs cleanup and a more elegant integration with the rest of the package
5. Creating a segmentation object that is compatible with `wholebrain` functions.
6. Forward warping and mapping the data onto the standardized mouse atlas.
7. Cleaning the mapped data in all the following ways: 
    + Removing cells that map outside the boundaries of the atlas.
    + Omitting regions by a default list of regions to omit.
    + Omitting regions by user specified region acronyms.
    + Removing Layer 1 cells
    + Removing cells from a contralateral hemisphere per slice if the registrations are divided by right and left hemispheres. 
8.  Obtaining cell counts normalized by region volume (per mm^2^) and region areas (per mm^2^). 
9.  TODO: Aggregating cell counts across multiple animals.
10. TODO: Splitting the hippocampal cell counts into Dorsal and Ventral based on a user-defined AP coordinate ranges.
11. TODO: Functions for easy analysis, e.g. cross correlations and network analysis.
  
  
<br>  

# Object oriented programming in R

Before getting started, it's helpful to get a sense of a how the structure of data is handled and bundled together in this pipeline. Data is now stored in S3 data type objects called `slice` and `mouse`. The data in these objects will be manipulated by a special type of function called a generic function (this is analogous to an object method in python). Generic functions allow you to pass objects of different classes to the same function, and it can recognize and perform different operations on objects depending on their class. If this is all confusing to you, don't worry at all! This is much more information than you actually need to know to use this pipeline. It's just helpful to better understand the architecture of the package.  


To get an excellent brief overview of what object oriented programming is and it's advantages over procedural programming, check out this excellent 
[YouTube video!](https://www.youtube.com/watch?v=pTB0EiLXUC8&t=379s&ab_channel=ProgrammingwithMosh) 


<br>  

# Install the `SMARTR` package in R

Currently the pipeline package is on my github, but it is a private respository. Therefore to download it from github using `devtools`, we need to feed the install function
a personal access token to access the github API. Install the package with the code below:

```{r}
# personal access token
auth_token <- "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"

# Install package
devtools::install_github("mjin1812/SMARTR", auth_token = auth_token)


```

<br>  

# Package object descriptions

A `slice` object will contain all the data related to registration, segmentation for each channel, and cell counts for a particular image.

It will also contain "metadata" about your experimental images, such as what the experimenter-assigned slice ID is, which brain atlas AP coordinate matches best, with the given image, and what the path to the image used for registration is. These metadata are stored as the object attributes.

Run the code below to used the `?` operator to pull up the documentation for a `slice` object. This will pull up a help page description of all the `slice` object attributes. 
The `::` or double colons helps tell R to specifically look for the object in the `SMARTR` package. 

```{r}
?SMARTR::slice

```



A `mouse` object is an object that will store multiple `slice` objects (and therefore all the information in it), and will eventually store the combined cell data 
and the normalized region cell counts by volume data. Like a `slice`, it will also contain "metadata" about your mouse stored as attributes. 
Now, try pulling up the help page yourself for the `mouse` object to see all attributes you can store!

<br>  


# Pipeline tutorial

Okay enough background! Let's walkthrough the pipeline with an example mouse and image to process.

## 1. Setting up the pipeline

```{r}
# First lets load the libraries we need to use!
library(SMARTR)
library(wholebrain)

```

### Initializing your mouse object 

```{r}

# Let's create an instance of a mouse object
# Let pretend this mouse object stores data from mouse No. 255  

mouse_255 <- mouse() 

# Let first see what's in it with print()
print(mouse_255)

# The output should print a bunch of important mouse attributes that haven't been set yet.

```
### Let's continue setting up the mouse object by storing the mouse attributes
 
```{r}

# We can access the list used to print the mouse attribute with the command below
mouse_info <- attr(mouse_255, 'info')

# Change mouse attributes to reflect your mouse and experiment
mouse_info$mouse_ID      <- '255'
mouse_info$sex           <- 'female'
mouse_info$strain        <- '129s'
mouse_info$experiment    <- 'sundowning'
mouse_info$group         <- 'control'
mouse_info$cohort        <- '3_2_months'
mouse_info$input_path    <- 'Y:\\Holly Hunsberger\\Sundowning_images\\Cohort 3_2month\\255'
mouse_info$output_path   <- 'C:\\Users\\Jinmich\\Documents\\255\\255_example_output'


# Change mouse's attributes by storing the mouse info list
attr(mouse_255, 'info') <- mouse_info

# Check the updates 
print(mouse_255)

```
We have now finished setting up a mouse object and are ready to store some imaging and automated cell count data into it!

### Initialize a slice object

```{r}
# Lets create an instance of a slice object. 
# Let pretend this slice object stores data from slice No. S1_10

slice_S1_10 <- slice()

# Let first see what's in it with print()
print(slice_S1_10)
```
### Let continue setting up slice attributes just like we did for a mouse!

```{r}
# We can access the list used to print the slice attribute with the command below
slice_info <- attr(slice_S1_10, 'info')

# Change slice attributes to reflect your slice and experiment
# Note that you should look at your image and compare it with a standardized mouse atlas to decide what the proper AP coordinate should be
slice_info$slice_ID            <- '1_10'
slice_info$coordinate          <- -3.15
slice_info$conversion_factor   <- 1.0    # Pixel-to-micron conversion factor
slice_info$bin                 <- 1
slice_info$z_width             <- 24     # z-stack thickness in microns
slice_info$hemisphere          <- 'left'
slice_info$channels            <- c('cfos', 'eyfp', 'colabel')   
slice_info$registration_path   <- 'Y:\\Holly Hunsberger\\Sundowning_images\\Cohort 3_2month\\255\\255_S1_10\\MAX_255_1_10.tif'  


# TODO allow slice attributes channels to be the default in the channels parameters in functions if none is supplied.
# TODO: allow for relative paths based on the mouse input directory

# Change slice attributes by storing the slice info list
attr(slice_S1_10, 'info') <- slice_info

# Check the updates 
print(slice_S1_10)

```

Note that if the physical brain was slanted when slicing, so that each hemisphere aligns to a different AP coordinate, then you need to initialize a new slice for each hemisphere to process each slice separately. Here I've created a slice just for the left hemisphere for example. Later we will clean data from the contralateral hemisphere, and vice-versa for the right side.

If the left and right side align well onto a single atlas plate, initialize only one slice object and set the `hemispshere` attribute to NULL (or don't set it, as this is the default anyway).


### Add slices to your mouse

We are ready to bundle our slice information with our mouse. But first a quick tip:


You can use the `$` operator to look at named elements in a mouse. Type the code below into the R console:


```
mouse_255$
```


You should see that a named list called `slices` pops up and you can complete the suggestion by hitting TAB.
The `$` operator is very useful for accessing any named element in a list. Right now, the `slices` list is NULL,
so it is empty and doesn't contain anything. That will change soon after we run the code below.


```{r}

# Check the length of slices in a mouse first
length(mouse_255$slices)

# Now lets check out the help page of one of the functions in SMARTR
# In general, always see the "Usage" or "Examples" section for examples of how to use a particular function in the package

?add_slice

# Now that we've read how to use the function, let's add our slice to our mouse with the line below:
mouse_255 <- add_slice(mouse_255, slice_S1_10)


# Check the length of slices now
length(mouse_255$slices)

# Access the new slice information with the code below
mouse_255$slices$`1_10_left`

```

## 2. The interactive registration process

### Finding a brain threshold to detect the contours around your image

Now we are ready to begin registering this image! For those of you who are new, registration is the process of aligning your imaging dataset with a standardized mouse atlas.
In order to do this, we use the package `wholebrain` to detect the boundaries of our brain sample before the package can generate it's best guess of how it maps to the boundaries of an atlas image. Unfortunately, most of the time the initial guess is way off with our images. 

Therefore, we pass a `filter` list as a parameter into the registration function. The `filter` is just a list of filtering parameters used for the base `wholebrain` segmentation function. One of these parameters is `brain.threshold` which is responsible for generating a good outline around the contours of our brain image. 

We will adjust and check the effects of changing the `brain.threshold` parameter using the base wholebrain function `segment`. This function pops up a GUI to manipulate the `brain.threshold` until we are satisfied with the blue outline detecting the contours of the brain.

I generally don't like this step as it is buggy and often crashes. Hopefully one day we find a threshold that universally works and can skip this step!


```{r}
# First we need to detect the boundaries of the brain in our images. 
# Lets load a pre-saved filter list in SMARTR and set it to the variable filter
filter <- SMARTR::filter

# To see what it contains
print(filter)

# Get the registration image
reg_path <- attr(mouse_255$slices$`1_10_left`, 'info')$registration_path

```

Adjust the filter parameter using the `segment` function below

```{r, eval = FALSE}

# Adjust brain threshold with the filter
seg_out <- wholebrain::segment(reg_path, filter = filter)

# Storing adjusted filter parameters back into the filter variable
filter <- seg_out$filter

```
  

### Register your image

The `register()` function is one of the generic functions of the package. Because of this, the useful documentation about what the function does depends on the type of objects being fed into it. The `register()` function can be used on both `slice` and `mouse` objects.

Pull up the help page with the code below:


```{r}
?register

```


Under the 'Usage' and 'Examples' sections, there are examples of how to use this function depending on if a `slice` or `mouse` is a function argument. The 'Value' section indicates what type of data is returned. From now on, you should get in the habit of pulling up the help pages for each new function you see. Now that we've read up, let register!


```{r, eval = FALSE}

# The `mouse` object may contain many slices, so you need to specify which `slice_ID` and which `hemisphere` you want to register
mouse_255 <-SMARTR::register(mouse_255, 
                      slice_ID = "1_10",
                      hemisphere = 'left',
                      filter = filter)

```


At this point, you may find it useful to save all your hard work after perfecting the registration. You can save to the mouse output folder with the command below.


```{r}
save_mouse(mouse_255)

```


## 3. Import raw segmentation data from ImageJ

The segmentation data from ImageJ is stored into .txt files. We can use the `import_segmentation()` generic function to import the raw data. 

Note that currently, this method is dependent on the naming conventions of the txt file, and therefore may be specific to Holly's data right now. In the future, if there are multiple different ImageJ segmentation macros with different naming conventions being used in the lab, we just need to write multiple custom import functions. This won't interfere with the rest of the pipeline.

```{r}
mouse_255 <- import_segmentation(mouse_255,
                                slice_ID = '1_10',
                                hemisphere = 'left',
                                channels = c('eyfp', 'cfos', 'colabel'))

```

## 4. Optional filtering of 'cfos' and 'eyfp' channels

```{r}

## There is currently a function written to create an eyfp or cfos filter. However this is not yet hardcoded into the package so we will skip this step.
## Since this eyfp filter is used to generate a segmentation object for the colabel channel, we will temporarily skip creating a segmentation object for this channel.
## We want to avoid hardcoding a dependency on the filter to process the colabel channel, as this function would no longer be optional. This will be figured out in the future... 


```


## 5. Creating a segmentation object 

We need to create a segmentation object compatible with `wholebrain` functions from the imported raw segmentation data. We'll use the `make_segmentation_object()` generic function. 


```{r, eval = FALSE}

# Set the use_filter parameter to FALSE to avoid using the filter for now
mouse_255 <- make_segmentation_object(mouse_255,
                                      slice_ID = '1_10',
                                      hemisphere = 'left',
                                      channels = c('eyfp', 'cfos'),
                                      use_filter = FALSE)

```



## 6. Forward warp data to atlas space

We are ready to map our segmentation data onto atlas space! We will forward warp our segmented cells onto atlas space with the `map_cells_to_atlas()` generic function. Within this function, the package calls `wholebrain::inspect.registration()` from the base wholebrain package. 


```{r, eval = FALSE}

mouse_255 <- map_cells_to_atlas(mouse_255,
                                slice_ID = '1_10',
                                hemisphere = 'left',
                                channels = c('eyfp', 'cfos'),
                                clean =  FALSE,
                                display = TRUE)
```



## 7. Cleaning mapped cell data

Now we can clean the data we've mapped. To demonstrate cleaning both the left and right sides of a slice, I'm going to cheat a little bit and just duplicate our slice with the mapped left side, and 
just change the hemisphere atttribute. 



```{r}
# Duplicate the left slice and add the right side as dummy data

slice_1_10_r <- mouse_255$slices$`1_10_left`
attr(slice_1_10_r, 'info')$hemisphere <-  'right'
mouse_255 <- add_slice(mouse_255, slice_1_10_r)

```


Now we have two slice object in our mouse, each belonging to one image. For each slice object, we want to exclude the contralateral hemisphere, clean up cell counts that map outside of the brain contours, ...


Cleaning the regions that we don't want


```{r}
mouse_255 <- exclude_anatomy(mouse_255, 
                        slice_ID = '1_10',
                        hemisphere = 'left',
                        channels = c("eyfp", "cfos"),
                        clean = TRUE, 
                        exclude_layer_1 = TRUE, 
                        exclude_other_hemisphere = TRUE)


```



```{r}
mouse_255 <- exclude_anatomy(mouse_255, 
                        slice_ID = '1_10',
                        hemisphere = 'right',
                        channels = c("eyfp", "cfos"),
                        clean = TRUE, 
                        exclude_layer_1 = TRUE, 
                        exclude_other_hemisphere = TRUE)


```



## 8. Getting cell counts per region normalized by volume or area in mm^3^ or mm^2^ respectively.

To get all the cell counts normalized 



Getting registered areas for all the regions in a slice object. Get registered areas for a particular slice

"1_10"  left and right hemispheres



```{r}

mouse_255 <- get_registered_areas(mouse_255,
                                  slice_ID = "1_10",
                                  hemisphere = "left",
                                  replace = TRUE)

mouse_255 <- get_registered_areas(mouse_255,
                                  slice_ID = "1_10",
                                  hemisphere = "right",
                                  replace = TRUE)


```


### Get a combined cell data table


```{r}

mouse_255 <- get_cell_table(mouse_255, channels = c("cfos", "eyfp"))


```



Once we have processed all the slices that we want per animal, we need to get normalized cell counts per volume.

```{r}


m <- normalize_cell_counts(m)


```




```{r}
# Loading premade data for convenience
load("C:/Users/Jinmich/Documents/255/255_example_output/mouse_255.RDATA")

```



</div>
</font> 
