---
title: "Denny Lab Wholebrain Pipeline Demo"
author: ' by Michelle Jin'
date: "August 9, 2021"
output:
  html_document: default
  word_document: default
---

<div style="line-height: 2em;">
<font size="4"> 
<style type="text/css">

h1.title {
  font-size: 38px;
  color: Black;
  text-align: center;
}
h4.author { /* Header 4 - and the author and data headers use this too  */
  font-size: 18px;
  color: Black;
  text-align: center;
}
h4.date { /* Header 4 - and the author and data headers use this too  */
  font-size: 18px;
  color: Black;
  text-align: center;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```



# Introduction

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook that allows for an interactive walkthrough of the wholebrain pipeline for the lab.. When you execute code within the notebook, the results will appear beneath the code. To execute a code chunk in this notebook click the *Run* button within a chunk or place your cursor inside it and pressing *Ctrl+Shift+Enter*. 

The base of this pipeline is an R package in development with the working title, `SMARTR`, a self-referential play on a previous package I developed as an extension to `wholebrain` called `SMART`. 

In this notebook, a prototypical example of of the following steps in processing data from a mouse will be demonstrated:

1. Setting up the pipeline by specifying experimental parameters and save directories.
2. The interactive registration process.
3. Importing raw segmentation data from .txt files generated from ImageJ for multiple channels.
4. Optionally creating a filter for the 'cfos' and 'eyfp' channels to clean segmented counts. 
5. Creating a segmentation object that is compatible with `wholebrain` functions.
6. Forward warping and mapping the data onto the standardized mouse atlas.
7. Cleaning the mapped data in all the following ways: 
    + Removing cells that map outside the boundaries of the atlas.
    + Omitting regions by a default list of regions to omit.
    + Omitting regions by user specified region acronyms.
    + Removing Layer 1 cells
    + Removing cells from a contralateral hemisphere per slice if the registrations are divided by right and left hemispheres. 
8.  Obtaining cell counts normalized by region volume (per mm^2^) and region areas (per mm^2^). 
9.  TODO: Splitting the hippocampal cell counts into Dorsal and Ventral based on a user-defined AP coordinate ranges.
10. TODO: Aggregating cell counts across multiple animals.
11. TODO: Functions for easy analysis, e.g. cross correlations and network analysis.
  
  
<br>  

# Object oriented programming in R

Before getting started, it's helpful to get a sense of a how the structure of data is handled and bundled together in this pipeline. Data is now stored in S3 data type objects called `slice` and `mouse`. The data in these objects will be manipulated by a special type of function called a generic function (this is analogous to an object method in python). Generic functions allow you to pass objects of different classes to the same function, and it can recognize and perform different operations on objects depending on their class. If this is all confusing to you, don't worry at all! This is much more information than you actually need to know to use this pipeline. It's just helpful to better understand the architecture of the package.  


To get an excellent brief overview of what object oriented programming is and it's advantages over procedural programming, check out this excellent 
[YouTube video!](https://www.youtube.com/watch?v=pTB0EiLXUC8&t=379s&ab_channel=ProgrammingwithMosh) 


<br>  

# Install the `SMARTR` package in R

Currently the pipeline package is on my github, but it is a private respository. Therefore to download it from github using the `devtools` package, we need to feed the install function a personal access token to access the github API. There are also some dependencies on the tidyverse packages so we will install that too. Install the package with the code below:

```{r, eval = FALSE}
# Install from CRAN
install.packages("tidyverse")

# personal access token
auth_token <- "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"

# Set the devtools install option to install for just 64bit architecture
options(devtools.install.args = "--no-multiarch")   

# Install package
devtools::install_github("mjin1812/SMARTR@main", auth_token = auth_token)


```

<br>  

We can now load the package!

```{r}
# Load SMARTR
library(SMARTR)
```

You can pull up the package description with the code below:

```{r}

?SMARTR

```


# Package object descriptions

A `slice` object will contain all the data related to registration, segmentation for each channel, and cell counts for a particular image.

It will also contain "metadata" about your experimental images, such as what the experimenter-assigned slice ID is, which brain atlas AP coordinate matches best with the given image, and what the path to the image used for registration is. These metadata are stored as the object's attributes.

Run the code below to used the `?` operator to pull up the documentation for a `slice` object. This will pull up a help page description of all the `slice` object attributes. 


```{r}
?SMARTR::slice

```

Note that the use of `::` or double colons here means that R specifically looks for a function, object, or help page in `SMARTR` package. This isn't necessary if you load the package, but it can sometimes help avoid ambiguity if there are identical names for things in other loaded packages.



A `mouse` object is an object that will store multiple `slice` objects (and therefore all the information in it), and will eventually store the combined cell data and the  region cell counts normalized by volume. Like a `slice`, it will also contain "metadata" about your mouse stored as attributes. Now, try pulling up the help page yourself for the `mouse` object to see all attributes you can store!

<br>  


# Pipeline tutorial

Okay enough background! Let's walkthrough the pipeline with an example mouse and image to process.

## 1. Setting up the pipeline


### Initializing your mouse object 

```{r}

# Let's create an instance of a mouse object
# This mouse object stores data from mouse No. 325

mouse_325 <- mouse() 

# Let first see what's in it with print()
print(mouse_325)

# The output should print a bunch of important mouse attributes that haven't been set yet.

```
### Let's continue setting up the mouse object by storing the mouse attributes

 
```{r}

# We can access the list used to print the mouse attribute with the command below
mouse_info <- attr(mouse_325, 'info')

# Change mouse attributes to reflect your mouse and experiment.
mouse_info$mouse_ID      <- '325'
mouse_info$sex           <- 'female'
mouse_info$strain        <- '129s'
mouse_info$experiment    <- 'sundowning'
mouse_info$group         <- 'control'
mouse_info$cohort        <- '4_2_months'
mouse_info$output_path   <- 'V:/Michelle Jin/Sundowning/PipelineDemo/325'


# Change mouse's attributes by storing the mouse info list
attr(mouse_325, 'info') <- mouse_info

# Check the updates 
print(mouse_325)

```
We have now finished setting up a mouse object and are ready to store some imaging and automated cell count data into it!

### Initialize a slice object

```{r}
# Lets create an instance of a slice object. 
# Let pretend this slice object stores data from slice No. S1_10

slice_2_5 <- slice()

# Let first see what's in it with print()
print(slice_2_5)
```
### Let continue setting up slice attributes just like we did for a mouse!

```{r}
# We can access the list used to print the slice attribute with the command below
slice_info <- attr(slice_2_5, 'info')

# Change slice attributes to reflect your slice and experiment
# Note that you should look at your image and compare it with a standardized mouse atlas to decide what the proper AP coordinate should be
slice_info$slice_ID            <- '2_5'
slice_info$coordinate          <- -1.63
slice_info$conversion_factor   <- 1.0833 # Pixel-to-micron conversion factor
slice_info$bin                 <- 1      # Whether the image was down sampled by a bin factor in imageJ
slice_info$z_width             <- 24     # z-stack thickness in microns
slice_info$hemisphere          <- NULL   # Set to 'left' or 'right' if processing a specific hemisphere
slice_info$channels            <- c('cfos', 'eyfp', 'colabel')   
slice_info$registration_path   <- 'Y:/Holly Hunsberger/Sundowning_images/Cohort4_2month/325/325_2_5/MAX_325_2_5.tif'  


# TODO allow slice attributes channels to be the default in the channels parameters in functions if none is supplied.
# TODO: allow for relative paths based on the mouse input directory

# Change slice attributes by storing the slice info list
attr(slice_2_5, 'info') <- slice_info

# Check the updates 
print(slice_2_5)

```

Note that if the physical brain was slanted when slicing, so that each hemisphere aligns to a different AP coordinate, then you need to initialize a new slice for each hemisphere to process each slice separately. Here I've created a slice including both hemispheres; later we will clean data from a right-hemisphere slice and omit the contralateral hemisphere for demonstration.

If the left and right side align well onto a single atlas plate, initialize only one slice object and set the `hemispshere` attribute to NULL (or don't set it, as this is the default anyway).


### Add slices to your mouse

We are ready to bundle our slice information with our mouse. But first a quick tip:


You can use the `$` operator to look at named elements in a mouse. Type the code below into the R console:


```
mouse_325$
```


You should see that a named list called `slices` pops up and you can complete the suggestion by hitting TAB.
The `$` operator is very useful for accessing any named element in a list. Right now, the `slices` list is NULL,
so it is empty and doesn't contain anything.


```{r}
# Check the length of slices in a mouse first
length(mouse_325$slices)

```


That will change soon after we add the slice into our mouse. Let's check out the help page of the function `add_slice()`. In general, always see the "Usage" or "Examples" section for examples of how to use a particular function in the package


```{r}

?add_slice

```

Now that we've read how to use the function, let's add our slice to our mouse with the line below:

```{r}
mouse_325 <- add_slice(mouse_325, slice_2_5)


# Check the length of slices now
length(mouse_325$slices)

# Access the new slice information with the code below
mouse_325$slices$`2_5`

```

## 2. The interactive registration process

### Finding a brain threshold to detect the contours around your image

Now we are ready to begin registering this image! For those of you who are new, registration is the process of aligning your imaging dataset with a standardized mouse atlas.
In order to do this, we use the package `wholebrain` to detect the boundaries of our brain sample before the package can generate it's best guess of how it maps to the boundaries of an atlas image. Unfortunately, most of the time the initial guess is way off with our images. 

Therefore, we pass a `filter` list as a parameter into the registration function. The `filter` is just a list of filtering parameters used for the base `wholebrain` segmentation function. One of these parameters is `brain.threshold` which is responsible for generating a good outline around the contours of our brain image. 

We will adjust and check the effects of changing the `brain.threshold` parameter using the base wholebrain function `segment`. This function pops up a GUI to manipulate the `brain.threshold` until we are satisfied with the blue outline detecting the contours of the brain.

I generally don't like this step as it is buggy and often crashes. Hopefully one day we find a threshold that universally works and can skip this step!


```{r}
# First we need to detect the boundaries of the brain in our images. 
# Lets load a pre-saved filter list in SMARTR and set it to the variable filter
filter <- SMARTR::filter

# To see what it contains
print(filter)

# Get the registration image
reg_path <- attr(mouse_325$slices$`2_5`, 'info')$registration_path

```

Adjust the filter parameter using the `segment` function below

```{r, eval = FALSE}

# Pre-adjusted to save time
filter$brain.threshold <- 8

# Adjust brain threshold with the filter
seg_out <- wholebrain::segment(reg_path, filter = filter)

# Storing adjusted filter parameters back into the filter variable
filter <- seg_out$filter

```
  

### Register your image

The `register()` function is one of the generic functions of the package. Because of this, the useful documentation about what the function does depends on the type of objects being fed into it. The `register()` function can be used on both `slice` and `mouse` objects.

Pull up the help page with the code below:


```{r}
?register

```


Under the 'Usage' and 'Examples' sections, there are examples of how to use this function depending on if a `slice` or `mouse` object is a function argument. The 'Value' section indicates what type of data is returned. From now on, you should get in the habit of pulling up the help pages for each new function you see. Now that we've read up, let register!


```{r, eval = FALSE}

# The `mouse` object may contain many slices, so you need to specify which `slice_ID` and which `hemisphere` you want to register
mouse_325 <- register(mouse_325, 
                      slice_ID = "2_5",
                      hemisphere = NULL,
                      filter = filter)

```


At this point, you may find it useful to save all your hard work after perfecting the registration. You can save to the mouse output folder with the command below.


```{r, eval = FALSE}
save_mouse(mouse_325)
```


To save time, we will now load a dataset that has been pre-registered:

```{r}
load("V:/Michelle Jin/Sundowning/PipelineDemo/325/mouse_325.RDATA")
```



## 3. Import raw segmentation data from ImageJ

The segmentation data from ImageJ is stored into .txt files. We can use the `import_segmentation()` generic function to import the raw data. 

Note that currently, this method is dependent on the naming conventions of the txt file, and therefore may be specific to Holly's data right now. In the future, if there are multiple different ImageJ segmentation macros with different naming conventions being used in the lab, we just need to write multiple custom import functions. This won't interfere with the rest of the pipeline.

```{r}
mouse_325 <- import_segmentation(mouse_325,
                                 slice_ID = '2_5',
                                 hemisphere = NULL,
                                 channels = c('eyfp', 'cfos', 'colabel'))

```

## 4. Optional filtering of 'cfos' and 'eyfp' channels

If you have gone through the process of identifying the best variables and ranges to filter out false positive counts from true positive counts for your dataset, you can used the `make_segmentation_filter()` to further pre-process your data. This function is flexible, in that it allows you to process either the eyfp channel, cfos channel, or both and allows for setting separate variables and filtering ranges for either channel.


```{r}

# Create a filter of non-cells for the eyfp channel

mouse_325 <- make_segmentation_filter(mouse_325,
                                      slice_ID = '2_5',
                                      hemisphere = NULL,
                                      channels = "eyfp",
                                      params = list(c("Vol..unit.", "Spher..unit.", "Moment1", "Moment2", "Moment3", "Moment4", "Moment5")),
                                      ranges = list(list(c(222, 8350),
                                                        c(0.43, 0.80),
                                                        c(0.45, 50),
                                                        c(0, 458),
                                                        c(0, 1097),
                                                        c(0, 4.4),
                                                        c(0, 0.035)
                                                        ))
                                      )

```


## 5. Creating a segmentation object 

We need to create a segmentation object compatible with `wholebrain` functions from the imported raw segmentation data. We'll use the `make_segmentation_object()` generic function. 


```{r, eval = FALSE}

# Set the use_filter parameter to FALSE to avoid using the filter for now
mouse_325 <- make_segmentation_object(mouse_325,
                                      slice_ID = '2_5',
                                      hemisphere = NULL,
                                      channels = c('eyfp', 'cfos', "colabel"),
                                      use_filter = TRUE)

```


## 6. Forward warp data to atlas space

We are ready to map our segmentation data onto atlas space! We will forward warp our segmented cells onto atlas space with the `map_cells_to_atlas()` generic function. Within this function, the package calls `wholebrain::inspect.registration()` from the base wholebrain package. 


```{r, eval = FALSE}

mouse_325 <- map_cells_to_atlas(mouse_325,
                                slice_ID = '2_5',
                                channels = c('eyfp', 'cfos', "colabel"),
                                clean =  FALSE,
                                display = TRUE)
```



## 7. Cleaning mapped cell data

Now we can clean the data we've mapped. To demonstrate cleaning of a slice with a single hemisphere, I'm going to cheat a little bit and just duplicate our slice and
just change the hemisphere atttribute. Let pretend this is just a completely different slice object from a separate section.


```{r}
# Duplicate the left slice and add the right side as dummy data
slice_2_5_r <- mouse_325$slices$`2_5`
attr(slice_2_5_r, 'info')$hemisphere <-  'right'
mouse_325 <- add_slice(mouse_325, slice_2_5_r)

```


Now we have two slice objects in our mouse, one with both hemispheres of data and another slice from which we only want the right hemisphere's data. 

For all slices you analyze, there may be a set automatic list of regions you'd like to exclude. This is automatically set as a slice attribute when you create it and you can edit it like any other slice attribute as demonstrated earlier. When you run the `exclude_anatomy` function, it will automatically omit these regions.

```{r}

# Print the default regions excluded list

print(attr(mouse_325$slices$`2_5`, "info")$regions_excluded)

```


For the right hemisphere slice object, we want to: 

* exclude the contralateral hemisphere
* clean up cell counts that map outside of the brain contours
* exclude cell counts from layer 1 of the cortex
* manually specify regions we want to exclude

Pull up the help page of `exclude_anatomy` to get the names of the arguments that accomplish these tasks.

In this example right-sided slice, I've specified the additional region VS to exclude both the VL and V3 (lateral and third ventricles). 


```{r}
mouse_325 <- exclude_anatomy(mouse_325, 
                        slice_ID = '2_5',
                        hemisphere = 'right',
                        channels = c("eyfp", "cfos", "colabel"),
                        clean = TRUE, 
                        exclude_regions = c("VS"),
                        exclude_layer_1 = TRUE, 
                        exclude_hemisphere = TRUE)


```


Let's do the same thing for the full slice, except we set exclude_hemisphere to FALSE since there is no hemisphere to exclude.


```{r}
mouse_325 <- exclude_anatomy(mouse_325, 
                        slice_ID = '2_5',
                        hemisphere = NULL,
                        channels = c("eyfp", "cfos", "colabel"),
                        clean = TRUE, 
                        exclude_regions = c("VS"),
                        exclude_layer_1 = TRUE, 
                        exclude_hemisphere = FALSE)

```



## 8. Getting cell counts per region normalized by volume or area in mm^3^ or mm^2^ respectively.


### Get slice areas

In order to get cell counts per region in each mouse normalized by volume, the exact area of each region in each slice needs to be calculated. This is accomplished with
the function  `get_registered_areas`. The function will automatically calculate region area per hemisphere. 



```{r}

# Calculate region areas for the full slice
mouse_325 <- get_registered_areas(mouse_325,
                                  slice_ID = "2_5",
                                  hemisphere = NULL)

# Calculate region areas for the right-hemisphere slice
mouse_325 <- get_registered_areas(mouse_325,
                                  slice_ID = "2_5",
                                  hemisphere = "right")


```


###  Get a combined cell data table 

This function aggregates all foward warped cell counts across all slices into one data frame. This can be especially useful for plotting purposes. 

```{r}

mouse_325 <- get_cell_table(mouse_325, channels = c("cfos", "eyfp", "colabel"))


```

You can access the cell table with the `$` operator (e.g. `mouse_325$cell_table$cfos`). We can use this aggregated dataset if we want to plot an interactive "glass brain" plot of all slices in the mouse.

```{r}
# Plot an interactive 3D plot of the cfos channel
SMART::glassbrain2(mouse_325$cell_table$eyfp, jitter = TRUE)
```


### Get normalized cell counts 

Once we have processed all the slices that we want per animal, we can get normalized cell counts per volume (mm^3^) and per area (mm^2^). 

```{r}
mouse_325 <- normalize_cell_counts(mouse_325, combine_hemispheres = TRUE, simplify_regions = FALSE)

print(mouse_325$normalized_counts)
```

## 9. Automatically generate DV Hippocampus datasets with user specified coordinates


```{r}

mouse_325 <- split_hipp_DV(mouse_325, AP_coord = -2.7, combine_hemispheres = TRUE, simplify_regions = FALSE, merge = FALSE)

# mouse_325$hipp_DV_normalized_counts$dorsal
```


## 10. Create experiment object that aggregates information from multiple mice


Once you've registered enough mice, you can begin adding them into an experiment object. Note that adding a mouse object will autopopulate
many of the experimental parameters. Additionally, adding mice to an experiment will keep only the aggregate processed neural mapping information so that unnecessary memory isn't being used during analysis. Any changes you want to make to cleaning up or modifying individual slice data should be done at the mouse object level. 


Check out the help page of an experiment object.


```{r}

sundowning <- experiment(experiment_name = "sundowning",
                         experimenters = c("HH", "AW", "MJ"),
                         output_path = "V:\\Michelle Jin\\Sundowning\\PipelineDemo\\Experiment_example")
 
sundowning <- add_mouse(sundowning, mouse_325)

```


Once you've added enough mice to perform an analysis...


```{r}
sundowning <- combine_norm_cell_counts(sundowning, by = c('group', 'sex'))

```



```{r}
save_experiment(sundowning, timestamp = TRUE)
```


## 11. TODO: Include analysis functions that auto generate plots






</div>
</font> 




# SCRATCH SCRATCH SCRATCH


```{r}
sundowning <- experiment(experiment_name = "sundowning",
                         experimenters = c("HH", "AW", "MJ"),
                         output_path = "V:\\Michelle Jin\\Sundowning\\PipelineDemo\\Experiment_example")
 

```

```{r}

for (k in 1:10){


# k <- 3

  load(paste0("V:/Michelle Jin/Sundowning/PipelineDemo/325/false_control_mouse_", k, ".RDATA"))
  print(m$normalized_counts$cfos[m$normalized_counts$cfos$acronym== "AAA",])

  sundowning <- add_mouse(sundowning, m, replace = TRUE)
}





```


```{r}

attr(sundowning, "info")$output_path <- "V:\\Michelle Jin\\Sundowning\\PipelineDemo\\Experiment_example"

save_experiment(e, timestamp = TRUE)
```



```{r}
e <- sundowning

e <- combine_norm_cell_counts(e)

e_info <- attr(e, "info")
```


Choose a random number of regions to delete from each test mouse's normalized cells count
```{r}
for (channel in e_info$channels){
# 
#   e$combined_normalized_counts[[channel]] <- e$combined_normalized_counts[[channel]][e$combined_normalized_counts[[channel]]$mouse_ID != "325",]
  nrows <- e$combined_normalized_counts[[channel]]$mouse_ID %>% length() 
  e$combined_normalized_counts[[channel]] <- e$combined_normalized_counts[[channel]] %>% sample_frac(size = .9, replace = FALSE)

}
```



```{r}
e <- enough_mice_per_group(e, by = c("group", "sex"), min_n = 4)
```

```{r}

save_experiment(e, timestamp = TRUE)

```



